# ストップウォッチサイト 基本設計書（フロントエンドのみ）

## 1. システム概要

### 1.1 サービス概要
カウントアップとカウントダウンを自由に選択可能なストップウォッチを提供するシンプルなWebサイト。フロントエンドのみで完結し、サーバーサイドの実装は不要。

### 1.2 主要機能
- **カウントアップモード**: 0秒からの経過時間計測
- **カウントダウンモード**: 設定時間からの逆算計時
- **操作機能**: 開始・停止・リセット
- **通知機能**: カウントダウン終了時の視覚的・ブラウザ通知
- **レスポンシブUI**: PC・スマートフォン対応

### 1.3 システムアーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                    ブラウザ環境                              │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐    ┌─────────────────┐                 │
│  │   React/Vue.js   │    │   LocalStorage   │                 │
│  │  (メインロジック) │◄──►│  (設定データ)    │                 │
│  └─────────────────┘    └─────────────────┘                 │
│           │                       │                          │
│           ▼                       ▼                          │
│  ┌─────────────────┐    ┌─────────────────┐                 │
│  │  Web Timer API   │    │ Notification API │                 │
│  │  (高精度計時)    │    │  (ブラウザ通知)  │                 │
│  └─────────────────┘    └─────────────────┘                 │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
                    ┌─────────────────┐
                    │  静的ホスティング │
                    │ (Netlify/Vercel) │
                    └─────────────────┘
```

## 2. 機能設計

### 2.1 カウントアップモード

#### 2.1.1 機能仕様
- **開始**: 0秒からカウント開始
- **停止**: 現在時刻で一時停止
- **リセット**: 0秒に戻る
- **表示形式**: HH:MM:SS.mmm（時:分:秒.ミリ秒）

#### 2.1.2 実装ロジック
```javascript
class CountUpTimer {
  constructor() {
    this.startTime = null;
    this.elapsedTime = 0;
    this.isRunning = false;
    this.intervalId = null;
  }
  
  start() {
    if (!this.isRunning) {
      this.startTime = Date.now() - this.elapsedTime;
      this.isRunning = true;
      this.intervalId = setInterval(() => {
        this.elapsedTime = Date.now() - this.startTime;
        this.updateDisplay();
      }, 10); // 10ms間隔で更新
    }
  }
  
  stop() {
    if (this.isRunning) {
      clearInterval(this.intervalId);
      this.isRunning = false;
    }
  }
  
  reset() {
    this.stop();
    this.elapsedTime = 0;
    this.updateDisplay();
  }
}
```

### 2.2 カウントダウンモード

#### 2.2.1 機能仕様
- **設定**: 時・分・秒の任意設定
- **開始**: 設定時間からカウントダウン開始
- **停止**: 現在時刻で一時停止
- **リセット**: 設定時間に戻る
- **終了**: 0秒到達時に通知

#### 2.2.2 実装ロジック
```javascript
class CountDownTimer {
  constructor(initialTime = 0) {
    this.initialTime = initialTime; // ミリ秒
    this.remainingTime = initialTime;
    this.isRunning = false;
    this.intervalId = null;
  }
  
  start() {
    if (!this.isRunning && this.remainingTime > 0) {
      this.isRunning = true;
      this.intervalId = setInterval(() => {
        this.remainingTime -= 10;
        this.updateDisplay();
        
        if (this.remainingTime <= 0) {
          this.remainingTime = 0;
          this.complete();
        }
      }, 10);
    }
  }
  
  complete() {
    this.stop();
    this.notifyCompletion();
  }
  
  notifyCompletion() {
    // 視覚的通知
    this.triggerVisualNotification();
    // ブラウザ通知
    this.triggerBrowserNotification();
  }
}
```

### 2.3 状態管理設計

#### 2.3.1 アプリケーション状態
```javascript
// React Context または Vue Store
const AppState = {
  // タイマー状態
  timer: {
    mode: 'countup' | 'countdown',
    isRunning: false,
    currentTime: 0,
    initialTime: 0, // カウントダウン用
    displayTime: '00:00:00.000'
  },
  
  // UI状態
  ui: {
    isSettingMode: false,
    notificationPermission: 'default' | 'granted' | 'denied',
    theme: 'light' | 'dark'
  },
  
  // 設定
  settings: {
    soundEnabled: true,
    vibrationEnabled: true,
    notificationEnabled: true
  }
};
```

## 3. UI/UX設計

### 3.1 画面構成

#### 3.1.1 メイン画面レイアウト
```
┌─────────────────────────────────────────┐
│              タイトル                    │
├─────────────────────────────────────────┤
│  [カウントアップ] [カウントダウン]      │ ← モード切り替え
├─────────────────────────────────────────┤
│                                         │
│         00:00:00.000                    │ ← 時間表示（大）
│                                         │
├─────────────────────────────────────────┤
│   [設定] (カウントダウン時のみ)         │ ← 時間設定
├─────────────────────────────────────────┤
│  [開始/停止]  [リセット]                │ ← 操作ボタン
├─────────────────────────────────────────┤
│          設定・オプション                │ ← 通知設定等
└─────────────────────────────────────────┘
```

#### 3.1.2 レスポンシブ対応
- **PC版**: 横幅最大800px、中央配置
- **スマホ版**: 全幅、縦レイアウト最適化
- **タブレット版**: 中間サイズ対応

### 3.2 コンポーネント設計

#### 3.2.1 React コンポーネント構成
```javascript
// メインコンポーネント
App
├── Header (タイトル・モード切り替え)
├── TimerDisplay (時間表示)
├── TimerControls (操作ボタン)
├── TimeSettings (時間設定・カウントダウン用)
├── NotificationSettings (通知設定)
└── Footer (オプション・設定)

// 主要コンポーネント詳細
const TimerDisplay = ({ time, isRunning, mode }) => {
  return (
    <div className={`timer-display ${isRunning ? 'running' : 'stopped'}`}>
      <div className="time-text">
        {formatTime(time)}
      </div>
    </div>
  );
};

const TimerControls = ({ onStart, onStop, onReset, isRunning }) => {
  return (
    <div className="timer-controls">
      <button 
        onClick={isRunning ? onStop : onStart}
        className={`control-btn ${isRunning ? 'stop' : 'start'}`}
      >
        {isRunning ? '停止' : '開始'}
      </button>
      <button onClick={onReset} className="control-btn reset">
        リセット
      </button>
    </div>
  );
};
```

#### 3.2.2 Vue.js コンポーネント構成
```javascript
// App.vue
<template>
  <div id="app">
    <Header @mode-change="changeMode" />
    <TimerDisplay :time="displayTime" :is-running="isRunning" />
    <TimeSettings v-if="mode === 'countdown'" @time-set="setTime" />
    <TimerControls 
      @start="startTimer" 
      @stop="stopTimer" 
      @reset="resetTimer"
      :is-running="isRunning"
    />
    <NotificationSettings @settings-change="updateSettings" />
  </div>
</template>
```

### 3.3 デザイン仕様

#### 3.3.1 カラーパレット
```css
:root {
  /* プライマリーカラー */
  --primary-color: #007bff;
  --primary-dark: #0056b3;
  --primary-light: #66b3ff;
  
  /* セカンダリーカラー */
  --secondary-color: #6c757d;
  --success-color: #28a745;
  --warning-color: #ffc107;
  --danger-color: #dc3545;
  
  /* ニュートラルカラー */
  --white: #ffffff;
  --light-gray: #f8f9fa;
  --gray: #6c757d;
  --dark-gray: #343a40;
  --black: #000000;
}
```

#### 3.3.2 タイポグラフィ
```css
/* 時間表示 */
.timer-display {
  font-family: 'Roboto Mono', monospace;
  font-size: clamp(2rem, 8vw, 4rem);
  font-weight: 700;
  letter-spacing: 0.1em;
}

/* ボタン */
.control-btn {
  font-family: 'Roboto', sans-serif;
  font-size: 1.2rem;
  font-weight: 500;
}

/* 一般テキスト */
body {
  font-family: 'Roboto', sans-serif;
  font-size: 1rem;
  line-height: 1.6;
}
```

## 4. 通知機能設計

### 4.1 視覚的通知

#### 4.1.1 画面点滅効果
```javascript
class VisualNotification {
  static flashScreen(duration = 3000) {
    const flashOverlay = document.createElement('div');
    flashOverlay.className = 'flash-overlay';
    document.body.appendChild(flashOverlay);
    
    // アニメーション
    flashOverlay.style.animation = `flash ${duration}ms ease-in-out`;
    
    setTimeout(() => {
      document.body.removeChild(flashOverlay);
    }, duration);
  }
  
  static pulseTimer() {
    const timerElement = document.querySelector('.timer-display');
    timerElement.classList.add('pulse-animation');
    
    setTimeout(() => {
      timerElement.classList.remove('pulse-animation');
    }, 2000);
  }
}
```

#### 4.1.2 CSS アニメーション
```css
/* 画面点滅 */
.flash-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.8);
  z-index: 9999;
  pointer-events: none;
}

@keyframes flash {
  0%, 100% { opacity: 0; }
  50% { opacity: 1; }
}

/* タイマー点滅 */
.pulse-animation {
  animation: pulse 0.5s ease-in-out infinite alternate;
}

@keyframes pulse {
  0% { transform: scale(1); }
  100% { transform: scale(1.1); }
}
```

### 4.2 ブラウザ通知

#### 4.2.1 通知許可管理
```javascript
class NotificationManager {
  static async requestPermission() {
    if ('Notification' in window) {
      const permission = await Notification.requestPermission();
      return permission === 'granted';
    }
    return false;
  }
  
  static showNotification(title, options = {}) {
    if (Notification.permission === 'granted') {
      new Notification(title, {
        body: options.body || 'カウントダウンが完了しました',
        icon: options.icon || '/favicon.ico',
        badge: options.badge || '/badge.png',
        tag: 'stopwatch-notification',
        requireInteraction: true,
        ...options
      });
    }
  }
}
```

## 5. 技術スタック

### 5.1 フロントエンド技術

#### 5.1.1 React版
```json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hooks": "^4.0.0"
  },
  "devDependencies": {
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "@vitejs/plugin-react": "^4.0.0",
    "typescript": "^5.0.0",
    "vite": "^4.0.0",
    "tailwindcss": "^3.0.0"
  }
}
```

#### 5.1.2 Vue.js版
```json
{
  "dependencies": {
    "vue": "^3.3.0",
    "vue-router": "^4.0.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^4.0.0",
    "@vue/tsconfig": "^0.4.0",
    "typescript": "^5.0.0",
    "vite": "^4.0.0",
    "tailwindcss": "^3.0.0"
  }
}
```

### 5.2 ビルド・開発環境

#### 5.2.1 Vite設定
```javascript
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  build: {
    outDir: 'dist',
    sourcemap: true,
    minify: 'terser',
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom']
        }
      }
    }
  },
  server: {
    port: 3000,
    open: true
  }
});
```

### 5.3 PWA対応

#### 5.3.1 Service Worker
```javascript
// service-worker.js
const CACHE_NAME = 'stopwatch-v1';
const urlsToCache = [
  '/',
  '/static/js/bundle.js',
  '/static/css/main.css',
  '/manifest.json'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(urlsToCache))
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => response || fetch(event.request))
  );
});
```

#### 5.3.2 Web App Manifest
```json
{
  "name": "ストップウォッチ",
  "short_name": "StopWatch",
  "description": "カウントアップ・カウントダウン対応ストップウォッチ",
  "start_url": "/",
  "display": "standalone",
  "theme_color": "#007bff",
  "background_color": "#ffffff",
  "icons": [
    {
      "src": "/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

## 6. 静的ホスティング環境

### 6.1 Netlify設定

#### 6.1.1 netlify.toml
```toml
[build]
  command = "npm run build"
  publish = "dist"

[build.environment]
  NODE_VERSION = "18"

[[headers]]
  for = "/*"
  [headers.values]
    X-Frame-Options = "DENY"
    X-XSS-Protection = "1; mode=block"
    X-Content-Type-Options = "nosniff"
    Referrer-Policy = "strict-origin-when-cross-origin"

[[headers]]
  for = "/service-worker.js"
  [headers.values]
    Cache-Control = "no-cache"
```

### 6.2 Vercel設定

#### 6.2.1 vercel.json
```json
{
  "buildCommand": "npm run build",
  "outputDirectory": "dist",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        }
      ]
    }
  ]
}
```

## 7. パフォーマンス最適化

### 7.1 高精度計時

#### 7.1.1 Performance API活用
```javascript
class HighPrecisionTimer {
  constructor() {
    this.startTime = 0;
    this.pausedTime = 0;
    this.isRunning = false;
  }
  
  start() {
    if (!this.isRunning) {
      this.startTime = performance.now() - this.pausedTime;
      this.isRunning = true;
      this.tick();
    }
  }
  
  tick() {
    if (this.isRunning) {
      const currentTime = performance.now() - this.startTime;
      this.updateDisplay(currentTime);
      requestAnimationFrame(() => this.tick());
    }
  }
  
  pause() {
    if (this.isRunning) {
      this.pausedTime = performance.now() - this.startTime;
      this.isRunning = false;
    }
  }
}
```

### 7.2 レンダリング最適化

#### 7.2.1 React最適化
```javascript
import { memo, useCallback, useMemo } from 'react';

const TimerDisplay = memo(({ time, isRunning }) => {
  const formattedTime = useMemo(() => {
    return formatTime(time);
  }, [time]);
  
  const displayClass = useMemo(() => {
    return `timer-display ${isRunning ? 'running' : 'stopped'}`;
  }, [isRunning]);
  
  return (
    <div className={displayClass}>
      <div className="time-text">{formattedTime}</div>
    </div>
  );
});
```

## 8. 実装手順

### 8.1 Phase 1: 基本構造
1. **プロジェクト初期化**
   - Create React App / Vue CLI セットアップ
   - TypeScript設定
   - Tailwind CSS導入

2. **基本UI実装**
   - レイアウトコンポーネント
   - タイマー表示コンポーネント
   - 操作ボタン

### 8.2 Phase 2: 機能実装
1. **カウントアップ機能**
   - 基本的な計時ロジック
   - 開始・停止・リセット

2. **カウントダウン機能**
   - 時間設定UI
   - カウントダウンロジック
   - 完了通知

### 8.3 Phase 3: 最適化
1. **パフォーマンス改善**
   - 高精度計時
   - レンダリング最適化

2. **PWA対応**
   - Service Worker
   - オフライン対応

## 9. テスト戦略

### 9.1 単体テスト
```javascript
// Timer.test.js
import { render, screen, fireEvent } from '@testing-library/react';
import Timer from './Timer';

describe('Timer Component', () => {
  test('starts counting up when start button is clicked', () => {
    render(<Timer mode="countup" />);
    const startButton = screen.getByText('開始');
    fireEvent.click(startButton);
    
    expect(screen.getByText('停止')).toBeInTheDocument();
  });
  
  test('resets to 00:00:00 when reset button is clicked', () => {
    render(<Timer mode="countup" />);
    const resetButton = screen.getByText('リセット');
    fireEvent.click(resetButton);
    
    expect(screen.getByText('00:00:00.000')).toBeInTheDocument();
  });
});
```

### 9.2 統合テスト
- モード切り替えテスト
- 通知機能テスト
- レスポンシブ表示テスト

---

**作成日**: 2025-01-11  
**バージョン**: 1.0  
**対象**: ストップウォッチサイト（フロントエンドのみ）  
**推奨環境**: モダンブラウザ（Chrome 90+, Firefox 88+, Safari 14+）