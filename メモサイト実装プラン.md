# メモサイト実装プラン（Phase別詳細）

## 概要

2面構成メモカードのWebアプリケーションを段階的に実装するプラン。各Phaseは独立して動作する完成品として設計され、学習効果を最大化しながらスキルアップできる構成。

## Phase 1: 基盤構築とコアUI（1-2週間）

### 1.1 プロジェクト初期化

#### セットアップコマンド
```bash
# プロジェクト作成
npm create vite@latest memo-app --template react-ts
cd memo-app

# 依存関係インストール
npm install @reduxjs/toolkit react-redux react-router-dom
npm install -D tailwindcss postcss autoprefixer
npm install uuid @types/uuid

# Tailwind CSS初期化
npx tailwindcss init -p
```

#### プロジェクト構造
```
src/
├── components/          # UIコンポーネント
│   ├── ui/             # 再利用可能なUIパーツ
│   ├── memo/           # メモ関連コンポーネント
│   └── layout/         # レイアウトコンポーネント
├── store/              # Redux状態管理
│   ├── slices/         # Redux slices
│   └── index.ts        # store設定
├── types/              # TypeScript型定義
├── utils/              # ユーティリティ関数
├── hooks/              # カスタムhooks
└── styles/             # グローバルスタイル
```

### 1.2 データ構造とRedux設定

#### 型定義 (types/memo.ts)
```typescript
export interface Memo {
  id: string;
  frontContent: string;
  backContent: string;
  createdAt: Date;
  updatedAt: Date;
  tags?: string[];
  color?: string;
  isStarred?: boolean;
}

export interface MemoState {
  items: Memo[];
  totalCount: number;
  currentPage: number;
  itemsPerPage: number;
  isLoading: boolean;
  error: string | null;
}

export interface UIState {
  selectedMemoId: string | null;
  isEditMode: boolean;
  searchQuery: string;
  sortBy: 'createdAt' | 'updatedAt' | 'alphabetical';
  sortOrder: 'asc' | 'desc';
}
```

#### Redux Store設定 (store/index.ts)
```typescript
import { configureStore } from '@reduxjs/toolkit';
import memoReducer from './slices/memoSlice';
import uiReducer from './slices/uiSlice';

export const store = configureStore({
  reducer: {
    memos: memoReducer,
    ui: uiReducer,
  },
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

#### メモスライス (store/slices/memoSlice.ts)
```typescript
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { Memo, MemoState } from '../../types/memo';

const initialState: MemoState = {
  items: [],
  totalCount: 0,
  currentPage: 1,
  itemsPerPage: 12,
  isLoading: false,
  error: null,
};

const memoSlice = createSlice({
  name: 'memos',
  initialState,
  reducers: {
    addMemo: (state, action: PayloadAction<Memo>) => {
      state.items.unshift(action.payload);
      state.totalCount += 1;
    },
    updateMemo: (state, action: PayloadAction<Memo>) => {
      const index = state.items.findIndex(memo => memo.id === action.payload.id);
      if (index !== -1) {
        state.items[index] = action.payload;
      }
    },
    deleteMemo: (state, action: PayloadAction<string>) => {
      state.items = state.items.filter(memo => memo.id !== action.payload);
      state.totalCount -= 1;
    },
    setMemos: (state, action: PayloadAction<Memo[]>) => {
      state.items = action.payload;
      state.totalCount = action.payload.length;
    },
  },
});

export const { addMemo, updateMemo, deleteMemo, setMemos } = memoSlice.actions;
export default memoSlice.reducer;
```

### 1.3 基本UIコンポーネント

#### Header コンポーネント (components/layout/Header.tsx)
```typescript
import React from 'react';

interface HeaderProps {
  onCreateMemo: () => void;
}

const Header: React.FC<HeaderProps> = ({ onCreateMemo }) => {
  return (
    <header className="bg-white shadow-sm border-b">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center h-16">
          <h1 className="text-2xl font-bold text-gray-900">
            📝 メモアプリ
          </h1>
          <button
            onClick={onCreateMemo}
            className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors"
          >
            + 新しいメモ
          </button>
        </div>
      </div>
    </header>
  );
};

export default Header;
```

#### MemoCard コンポーネント (components/memo/MemoCard.tsx)
```typescript
import React, { useState } from 'react';
import { Memo } from '../../types/memo';

interface MemoCardProps {
  memo: Memo;
  onEdit: (memo: Memo) => void;
  onDelete: (id: string) => void;
}

const MemoCard: React.FC<MemoCardProps> = ({ memo, onEdit, onDelete }) => {
  const [isFlipped, setIsFlipped] = useState(false);

  const handleCardClick = () => {
    setIsFlipped(!isFlipped);
  };

  const handleEditClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    onEdit(memo);
  };

  const handleDeleteClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (window.confirm('このメモを削除しますか？')) {
      onDelete(memo.id);
    }
  };

  return (
    <div className="memo-card-container perspective-1000 h-48 cursor-pointer">
      <div
        className={`memo-card relative w-full h-full transform-style-preserve-3d transition-transform duration-600 ${
          isFlipped ? 'rotate-y-180' : ''
        }`}
        onClick={handleCardClick}
      >
        {/* 表面 */}
        <div className="card-face absolute w-full h-full backface-hidden bg-gradient-to-br from-blue-500 to-purple-600 rounded-lg p-4 flex flex-col justify-between text-white">
          <div className="font-semibold text-lg">
            {memo.frontContent || 'クリックして内容を追加'}
          </div>
          <div className="flex justify-between opacity-75">
            <button
              onClick={handleEditClick}
              className="text-sm hover:bg-white/20 px-2 py-1 rounded"
            >
              編集
            </button>
            <button
              onClick={handleDeleteClick}
              className="text-sm hover:bg-white/20 px-2 py-1 rounded"
            >
              削除
            </button>
          </div>
        </div>

        {/* 裏面 */}
        <div className="card-face absolute w-full h-full backface-hidden rotate-y-180 bg-gradient-to-br from-green-500 to-teal-600 rounded-lg p-4 flex flex-col justify-between text-white">
          <div className="text-sm">
            {memo.backContent || '裏面の内容を追加'}
          </div>
          <div className="flex justify-between opacity-75">
            <button
              onClick={handleEditClick}
              className="text-sm hover:bg-white/20 px-2 py-1 rounded"
            >
              編集
            </button>
            <button
              onClick={handleDeleteClick}
              className="text-sm hover:bg-white/20 px-2 py-1 rounded"
            >
              削除
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default MemoCard;
```

#### MemoGrid コンポーネント (components/memo/MemoGrid.tsx)
```typescript
import React from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '../../store';
import MemoCard from './MemoCard';
import { Memo } from '../../types/memo';

interface MemoGridProps {
  onEditMemo: (memo: Memo) => void;
  onDeleteMemo: (id: string) => void;
}

const MemoGrid: React.FC<MemoGridProps> = ({ onEditMemo, onDeleteMemo }) => {
  const memos = useSelector((state: RootState) => state.memos.items);

  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 p-6">
      {memos.map((memo) => (
        <MemoCard
          key={memo.id}
          memo={memo}
          onEdit={onEditMemo}
          onDelete={onDeleteMemo}
        />
      ))}
    </div>
  );
};

export default MemoGrid;
```

### 1.4 CRUD操作実装

#### MemoForm コンポーネント (components/memo/MemoForm.tsx)
```typescript
import React, { useState, useEffect } from 'react';
import { Memo } from '../../types/memo';

interface MemoFormProps {
  memo?: Memo;
  isOpen: boolean;
  onClose: () => void;
  onSave: (frontContent: string, backContent: string) => void;
}

const MemoForm: React.FC<MemoFormProps> = ({ memo, isOpen, onClose, onSave }) => {
  const [frontContent, setFrontContent] = useState('');
  const [backContent, setBackContent] = useState('');

  useEffect(() => {
    if (memo) {
      setFrontContent(memo.frontContent);
      setBackContent(memo.backContent);
    } else {
      setFrontContent('');
      setBackContent('');
    }
  }, [memo]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (frontContent.trim() || backContent.trim()) {
      onSave(frontContent, backContent);
      onClose();
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 w-full max-w-md mx-4">
        <h2 className="text-xl font-bold mb-4">
          {memo ? 'メモを編集' : '新しいメモ'}
        </h2>
        
        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              表面の内容
            </label>
            <textarea
              value={frontContent}
              onChange={(e) => setFrontContent(e.target.value)}
              className="w-full p-3 border border-gray-300 rounded-md resize-none"
              rows={3}
              placeholder="表面の内容を入力..."
            />
          </div>
          
          <div className="mb-6">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              裏面の内容
            </label>
            <textarea
              value={backContent}
              onChange={(e) => setBackContent(e.target.value)}
              className="w-full p-3 border border-gray-300 rounded-md resize-none"
              rows={3}
              placeholder="裏面の内容を入力..."
            />
          </div>
          
          <div className="flex justify-end space-x-3">
            <button
              type="button"
              onClick={onClose}
              className="px-4 py-2 text-gray-700 bg-gray-200 rounded-md hover:bg-gray-300"
            >
              キャンセル
            </button>
            <button
              type="submit"
              className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
            >
              保存
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default MemoForm;
```

### 1.5 ローカルストレージ統合

#### LocalStorage Manager (utils/localStorage.ts)
```typescript
import { Memo } from '../types/memo';

const STORAGE_KEY = 'memo-app-data';

export class LocalStorageManager {
  static save(memos: Memo[]): void {
    try {
      const data = {
        memos,
        lastUpdated: new Date().toISOString(),
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    } catch (error) {
      console.error('Failed to save to localStorage:', error);
    }
  }

  static load(): Memo[] {
    try {
      const data = localStorage.getItem(STORAGE_KEY);
      if (!data) return [];
      
      const parsed = JSON.parse(data);
      return parsed.memos || [];
    } catch (error) {
      console.error('Failed to load from localStorage:', error);
      return [];
    }
  }

  static clear(): void {
    localStorage.removeItem(STORAGE_KEY);
  }
}
```

#### Redux Middleware (store/middleware/localStorage.ts)
```typescript
import { Middleware } from '@reduxjs/toolkit';
import { LocalStorageManager } from '../../utils/localStorage';

export const localStorageMiddleware: Middleware = (store) => (next) => (action) => {
  const result = next(action);
  
  // メモ関連のアクションの場合、ローカルストレージに保存
  if (action.type.startsWith('memos/')) {
    const state = store.getState();
    LocalStorageManager.save(state.memos.items);
  }
  
  return result;
};
```

### 1.6 メインApp統合

#### App.tsx
```typescript
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { v4 as uuidv4 } from 'uuid';
import Header from './components/layout/Header';
import MemoGrid from './components/memo/MemoGrid';
import MemoForm from './components/memo/MemoForm';
import { addMemo, updateMemo, deleteMemo, setMemos } from './store/slices/memoSlice';
import { LocalStorageManager } from './utils/localStorage';
import { Memo } from './types/memo';
import { RootState } from './store';

function App() {
  const dispatch = useDispatch();
  const [isFormOpen, setIsFormOpen] = useState(false);
  const [editingMemo, setEditingMemo] = useState<Memo | undefined>();

  // 初期データロード
  useEffect(() => {
    const savedMemos = LocalStorageManager.load();
    dispatch(setMemos(savedMemos));
  }, [dispatch]);

  const handleCreateMemo = () => {
    setEditingMemo(undefined);
    setIsFormOpen(true);
  };

  const handleEditMemo = (memo: Memo) => {
    setEditingMemo(memo);
    setIsFormOpen(true);
  };

  const handleSaveMemo = (frontContent: string, backContent: string) => {
    if (editingMemo) {
      // 編集
      const updatedMemo: Memo = {
        ...editingMemo,
        frontContent,
        backContent,
        updatedAt: new Date(),
      };
      dispatch(updateMemo(updatedMemo));
    } else {
      // 新規作成
      const newMemo: Memo = {
        id: uuidv4(),
        frontContent,
        backContent,
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      dispatch(addMemo(newMemo));
    }
  };

  const handleDeleteMemo = (id: string) => {
    dispatch(deleteMemo(id));
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <Header onCreateMemo={handleCreateMemo} />
      <main>
        <MemoGrid
          onEditMemo={handleEditMemo}
          onDeleteMemo={handleDeleteMemo}
        />
      </main>
      <MemoForm
        memo={editingMemo}
        isOpen={isFormOpen}
        onClose={() => setIsFormOpen(false)}
        onSave={handleSaveMemo}
      />
    </div>
  );
}

export default App;
```

## Tailwind CSS設定

#### tailwind.config.js
```javascript
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      perspective: {
        '1000': '1000px',
      },
      transformStyle: {
        'preserve-3d': 'preserve-3d',
      },
      backfaceVisibility: {
        'hidden': 'hidden',
      },
      rotate: {
        'y-180': 'rotateY(180deg)',
      },
    },
  },
  plugins: [],
}
```

## Phase 1 完了チェックリスト

- [ ] プロジェクト初期化完了
- [ ] TypeScript型定義作成
- [ ] Redux store設定
- [ ] 基本UIコンポーネント実装
- [ ] CRUD操作実装
- [ ] ローカルストレージ統合
- [ ] レスポンシブデザイン対応
- [ ] 基本テスト実行

## 次のPhase予告

**Phase 2** では以下を実装予定：
- カードフリップアニメーション
- 検索・フィルタリング機能
- ページネーション
- 高度なソート機能

---

**更新日**: 2025-01-11  
**対象**: Phase 1 実装詳細  
**推定工数**: 1-2週間